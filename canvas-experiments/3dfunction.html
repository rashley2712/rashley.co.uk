<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<head>
	<link rel="stylesheet" type="text/css" href="styles.css">
	<title>Spheres in 3D using three.js</title>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
<script src="modernizr.js"></script>
<script src="jquery191.js"></script>
<script src="three.js"></script>
<script src="OrbitControls.js"></script>
<script type="text/javascript">
	'use strict';
	
	// Set up everything when the page had finished loading
	window.addEventListener("load", eventWindowLoaded, false);
	
	var scene;
	var camera;
	var geometry;
	var material;
	var cube;
	var light;
	var controls;
	var sphereWD;
	var ticker;
	var lights;
	var renderer;
	var plane;
	
	
	var q = m2/m1;
	var msol = 1.989e30;  	// Solar mass (kg)
	var rsol = 695700000; 	// Solar radius (m)
	var G = 6.678e-11;  	// Gravitational constant (m^3/kg/s^2)
	var au = 149597870700; 	// AU (m)
	
	var m1 = 0.535 * msol;	// Primary mass (solar masses)
	var m2 = 0.111 * msol;	// Secondary mass (solar masses)
	var a = 0.434 * rsol;	// Semimajor axis (solar radii)
	var T = 3600;    		// Period (s)
	
	var maxZ = 0;
	var minZ = 0;
	
	function f(x, y, z) {
		//return Math.sqrt(x*x + y*y);
		//return Math.cos(Math.abs(x)+Math.abs(y))*(Math.abs(x)+Math.abs(y))
		x = x*rsol;
		y = y*rsol;
		z = z*rsol;	
		var xcm = a * m2 / (m1 + m2);
		var omega = Math.PI * 2 / T;
		var r1 = Math.sqrt(x*x + y*y + z*z);
		var r2 = Math.sqrt((x-a)*(x-a) + y*y + z*z);
		var potential = - G*m1/r1 - G*m2/r2 - omega*omega/2 * ( (x-xcm)*(x-xcm) + y*y);
		console.log(potential);
		return potential / 1953716102138.4692;
	}
	
	function shiftVertices(model) {
		for (var i in model.geometry.vertices) {
			var x = model.geometry.vertices[i].x;
			var y = model.geometry.vertices[i].y;
			var z = model.geometry.vertices[i].z;
			var z = f(x, y, z);
			model.geometry.vertices[i].z = z;
		}
		model.geometry.verticesNeedUpdate = true;
		model.geometry.normalsNeedUpdate = true;
		model.geometry.computeBoundingSphere();
		model.geometry.computeFaceNormals();
		model.geometry.computeVertexNormals();
	}
	
	function initModels() {
		console.log("Initialising models and scene");
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 1000 );
	    
		var planeGeometry = new THREE.PlaneGeometry( 2, 2, 128, 128 );
		var planeMaterial = new THREE.MeshPhongMaterial( {color: 0xaaaaaa, side: THREE.DoubleSide, wireframe: true} );
		plane = new THREE.Mesh( planeGeometry, planeMaterial );
		shiftVertices(plane);
		scene.add(plane);
		
		var light1 = new THREE.PointLight( 0xffc184, 1, 0 );
		light1.position.set( 10, 20, 100 );
		scene.add(light1);
		var light2 = new THREE.AmbientLight( 0xffffff);
		light2.position.set( 100, 200, -100 );
		scene.add(light1);
		
		var pointLight = new THREE.PointLight( 0xffffff, 1, 100 );
		pointLight.position.set( 10, 10, 20 );
		scene.add( pointLight );

		var sphereSize = 1;
		var pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
		scene.add( pointLightHelper );
		
		camera.position.x = 1;
		camera.position.z = 4;
		//camera.position.y = 30;
		scene.add(camera);
		
		// Add OrbitControls so that we can pan around with the mouse.
	    controls = new THREE.OrbitControls(camera, renderer.domElement);
	}
	
	function eventWindowLoaded() {
		console.log("Page loaded....");
		renderer = new THREE.WebGLRenderer({ antialias: true});
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild(renderer.domElement);
		initModels();
		ticker = 0;
		render();
	}
	
	function render() {
		
		renderer.render(scene, camera);
		plane.rotation.z+= 0.001;
		requestAnimationFrame( render );
		
	}
	
	

</script>
</head>

	<body>
	
		
	
	</body>



</html>
